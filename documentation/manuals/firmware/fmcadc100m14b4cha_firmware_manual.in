\input texinfo    @c -*-texinfo-*-
%
% fmcadc100m14b4cha_firmware_manual.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding UTF-8
@setfilename fmcadc100m14b4cha_firmware_manual.info
@settitle fmcadc100m14b4cha_firmware_manual
@iftex
@afourpaper
@end iftex
@paragraphindent 3
@comment %**end of header

@setchapternewpage off

@set update-month April 2013

@finalout

@titlepage
@title FmcAdc100m14b4cha Firmware Guide
@subtitle @value{update-month}
@subtitle Simple PCIe FMC Carrier (SPEC) version
@sp 10
@center @image{../../figures/cern_logo,3cm,,,pdf} @hfill @image{../../figures/ohr_logo,3cm,,,pdf}
@author Matthieu Cattin (CERN)
@end titlepage
@headings single

@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This document describes the hdl developed to support the FmcAdc100m14b4cha@footnote{http://www.ohwr.org/projects/fmc-adc-100m14b4cha} (later refered to as fmc-adc) mezzanine card on the SPEC@footnote{http://www.ohwr.org/projects/spec} carrier card.

@c ##########################################################################
@node Architecture
@chapter Architecture

This chapter describes the internal blocks of the FPGA.
All blocks (except the memory controller) are connected to the PCIe bridge interface through a Wishbone bus. The DDR memory can only be access through DMA.
The @ref{fig:firmware_arch} illustrates the FPGA architecture. The peripherals connected to each block are also shown.
A crossbar from the general-cores@footnote{http://www.ohwr.org/projects/general-cores} library is used to map the Wishbone slaves in the BAR 0 address space.
The following table shows the memory mapping.

@float Table,tab:memory_map
@multitable {Byte offset}{xwb_onewire_master}{fmc-adc-100m14b4cha}{Mezzanine system @math{I^2C} master}
@headitem Byte offset @tab Core @tab Library @tab Description
@item @code{0x0000} @tab sdb_rom            @tab general-cores       @tab SDB records
@item @code{0x1000} @tab gn4124_core        @tab gn4124-core         @tab DMA controller
@item @code{0x1100} @tab -                  @tab -                   @tab Carrier SPI master@footnote{Not implemented.}
@item @code{0x1200} @tab xwb_onewire_master @tab general-cores       @tab Carrier 1-wire master
@item @code{0x1300} @tab carrier_csr        @tab fmc-adc-100m14b4cha @tab Carrier control and status
@item @code{0x1400} @tab utc_core           @tab fmc-adc-100m14b4cha @tab Time-tagging core
@item @code{0x1500} @tab irq_controller     @tab fmc-adc-100m14b4cha @tab Interrupt controller
@item @code{0x1600} @tab xwb_i2c_master     @tab general-cores       @tab Mezzanine system @math{I^2C} master
@item @code{0x1700} @tab xwb_spi            @tab general-cores       @tab Mezzanine SPI master
@item @code{0x1800} @tab xwb_i2c_master     @tab general-cores       @tab Mezzanine @math{I^2C} master
@item @code{0x1900} @tab fmc_adc_100Ms_core @tab fmc-adc-100m14b4cha @tab ADC core
@item @code{0x1A00} @tab xwb_onewire_master @tab general-cores       @tab Mezzanine 1-wire master
@end multitable
@caption{Wishbone bus memory mapping (BAR 0).}
@end float

The Wishbone crossbar also implements SDB@footnote{http://www.ohwr.org/projects/fpga-config-space} records. Those records describes the Wishbone slaves and their mapping on the bus.
The SDB records ROM must be located at offset @code{0x0}.

Note that some of the cores from the general-cores library are based on cores from OpenCores@footnote{http://opencores.org/}. Therefore, the documentation for those cores is hosted on the OpenCores website.

The register description for the cores for the carrier control and status, the time-tagging core, the interrupt controller and the ADC core can be found in annexe.

@float Figure,fig:firmware_arch
@center @image{../../figures/firmware_arch, 15cm,,,pdf}
@caption{FPGA firmware architecture block diargam.}
@end float

@table @b
@item TODO
      registers are 32-bits
@end table

@c --------------------------------------------------------------------------
@section Clock domains

The fmc-adc design has four different clock domains. They are listed in the followig table.

@float Table,tab:clocks
@multitable {@code{sys_clk_125}}{DDR interface clock}{125.00 MHz}{Si570 on the fmc-adc mezzanine.}
@headitem Name @tab Description @tab Frequency @tab Source
@item @code{sys_clk_125} @tab Main system clock @tab 125.00 MHz @tab 20MHz TCXO (carrier)
@item @code{ddr_clk} @tab DDR interface clock @tab 333.33 MHz @tab 20MHz TCXO (carrier)
@item @code{fs_clk} @tab Sampling clock @tab 100.00 MHz @tab Si570 (mezzanine)
@item @code{p2l_clk} @tab Local bus clock @tab 200.00 MHz @tab GN4124 (carrier)
@end multitable
@caption{Clock domains.}
@end float

@b{Note:} By default, the sampling clock is 100MHz. But is can be changed to any frequency from 10MHz to 105MHz. The lower bound is defined by the Si570 programmable oscillator. While the upper bound is limited by the LTC2174 ADC.

@c --------------------------------------------------------------------------
@section GN4124 core

This block is the interface between the GN4124@footnote{PCI Express bridge from Semtech (was Gennum)} local bus and the other blocks in the FPGA.
The GN4124 is a four lane PCI Express bridge. In addition to th PHY, it also contains the data link and transaction layers.
The GN4124 bridge is used to access the FPGA registers, but also to generate MSI interrupts and re-program the FPGA.
The BAR 4 (Base Address Register) allows access to the GN4124 internal registers.
The BAR 0 is connected to the local bus and therefore allows access to the FPGA.

The GN4124 core is made of a local bus interface with the GN4124 chip, a Wishbone bus master mapped to BAR0 and a DMA controller. The DMA controller has two Wishbone ports. A Wishbone slave to configure the DMA controller and a Wishbone master to access the DDR memory.

@table @b
@item TODO
      wb addr alignment
@item TODO
      ddr memory access (interleaved, no address converter)
@item TODO
      wb buses size
@end table

@c --------------------------------------------------------------------------
@section Carrier control and status

This block contains control and status registers related to the carrier board.
A first register allows to readout the carrier PCB revision and carrier type.
Another register signals the presence of a mezzanine in the FMC slot, gives the status of the local bus and system PLLs and indicates the DDR memory controller calibration state.
The last register of this block allows to control the carrier's LEDs on the front panel. There is on red and one green LED.

@c --------------------------------------------------------------------------
@section Carrier 1-wire master

This 1-wire master controls the DS18B20 thermometer chip located on the carrier board.
This chip also contains a unique 64-bit identifier.
This block is based on an OpenCores design.

@table @b
@item TODO
      add ref to opencores doc
@end table

@c --------------------------------------------------------------------------
@section Carrier SPI master

The carrier SPI master is not implemented. It is meant to control DACs connected to VCXO for White Rabbit@footnote{http://www.ohwr.org/projects/white-rabbit} applications.

@c --------------------------------------------------------------------------
@section Memory controller

The memory controller block is the interface between the 256MB DDR memory located on the SPEC board and the other blocks in the FPGA.
It is basically a MCB core (Memory Controller Block) generated with Xilinx CoreGen and an additional wrapper implementing two Wishbone slave interfaces.
One of the Wishbone slave interface is connected to the ADC core.
The other Wishbone slave interface is connected to the DMA Wishbone master of the GN4124 core.

@float Table,tab:mem_ctrl_ports
@multitable {WB Slave}{GN4124 core}{Data width}{Access type}
@headitem WB Slave @tab WB Master @tab Data width @tab Access type
@item @code{0} @tab ADC core @tab 64-bit @tab Write only
@item @code{1} @tab GN4124 core @tab 32-bit @tab Read/write
@end multitable
@caption{Memory controller Wishbone interfaces.}
@end float

@table @b
@item TODO
      max bandwidth, concurent access, ...
@item TODO
      add ref to ddr core, xilinx doc
@end table

@c --------------------------------------------------------------------------
@section Interrupt controller

The interrupt controller purpose is to concentrate several interrupt source into one interrupt request line. It has four interrupt inputs and one interrupt request output.
It also have one interrupt enable mask register and one interrupt source register.
Each time a valid rising edge is detected on one of the inputs, a pulse is generated on the interrupt request output.
The interrupt request output is connected to the GPIO 8 of the GN4124 chip.
Note that the GN4124 must be configured to generate a MSI when a rising edge is detected on GPIO 8.
A rising edge is valid if the corresponding bit in the interrupt enable mask register is set.
When a valid rising edge is detected, the corresponding bit in the interrupt source register is set as well. This indicates to the host which source caused the interrput.
To clear a bit in the interrupt source register, a '1' must be written to it.

@noindent There are four interrupt sources in the design. They are listed below.

@table @b
@item DMA done
      This interrupt signals the end of a DMA transfer.
@item DMA error
      This interrupt signals an error in a DMA transfer.
@item Trigger
      This interrupt signals that a valid trigger arrived while the acquisition state machine was in the "wait trigger" state.
@item Acquisition end
      This interrupt signals the end of an acquisition. In case of multi-shot acquisition, it occurs at the end of the last shot.
@end table

@table @b
@item TODO
      explain the multi-irq register (or remove it!)
@end table

@c --------------------------------------------------------------------------
@section Time-tagging core

This block allows time-tagging of interresting events in the ADC core.
It is based on a seconds counter and a 125MHz system clock ticks counter.
Those two counters are accessible in read/write mode via registers.
To time-tag the events, the ADC core sends pulses to the time-tagging core.
The following events are time-tagged; trigger, acquisition start, acquisition stop and acquisition end.

@c --------------------------------------------------------------------------
@section ADC core

The ADC core is the main block of the design.
On the mezzanine interface side, it takes a data flow from the LTC2174 ADC chip, an external trigger and controls the analogue switches to select the input range or calibration mode.
On the internal interface side, it has a Wishbone master to write data to the DDR memory controller.
It also has a Wishbone slave to access the core's control and status regiters.
In addition, it outputs the following event as pulses:
@itemize @bullet
@item Trigger
@item Acquisition start
@item Acquisition stop
@item Acquisition end
@end itemize
The internal detailed functionning of this block is described further in the document(@xref{Configuration}, @ref{Acquisition} and @ref{Calibration}).

@c --------------------------------------------------------------------------
@section Mezzanine SPI master

This SPI master controls the LTC2174 ADC and the four MAX5442 offset DACs.
The following table shows how the peripherals are wired to the core.
This block is based on an OpenCores design.

@float Table,tab:spi_ss
@multitable @columnfractions .12 .35
@headitem Slave select @tab Peripheral
@item @code{0} @tab LTC2174 ADC
@item @code{1} @tab MAX5442 DAC for channel 1
@item @code{2} @tab MAX5442 DAC for channel 2
@item @code{3} @tab MAX5442 DAC for channel 3
@item @code{4} @tab MAX5442 DAC for channel 4
@end multitable
@caption{Mezzanine SPI slave select lines mapping.}
@end float

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to LTC2174, MAX5442 datasheet
@end table

@c --------------------------------------------------------------------------
@section Mezzanine 1-wire master

This 1-wire master controls the DS18B20 thermometer chip located on the mezzanine board.
This chip also contains a unique 64-bit identifier.
This block is based on an OpenCores design.

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to DS18B20 datasheet
@end table

@c --------------------------------------------------------------------------
@section Mezzanine @math{I^2C} master

This @math{I^2C} master controls the Si570 programmable oscillator chip located on the mezzanine board.
This chip is used to produce the ADC sampling clock.
This block is based on an OpenCores design.

@float Table,tab:i2c_slave
@multitable @columnfractions .15 .50
@headitem Slave address @tab Peripheral
@item @code{0x55} @tab Si570 programmable oscillator
@end multitable
@caption{Mezzanine @math{I^2C} slaves mapping.}
@end float

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to Si570 datasheet
@end table

@c --------------------------------------------------------------------------
@section Mezzanine system management @math{I^2C} master

This @math{I^2C} master access the 24AA64T 64Kb EEPROM memory chip located on the mezzanine board.
This memory is mandatory as specified in the FMC standard (VITA 57.1). It is connected to the system management @math{I^2C} bus, also specified in the FMC standard.
This block is based on an OpenCores design.

@float Table,tab:sys_i2c_slave
@multitable @columnfractions .15 .50
@headitem Slave address @tab Peripheral
@item @code{0x50} @tab 24AA64T 64Kb EEPROM memory
@end multitable
@caption{Mezzanine system management @math{I^2C} slaves mapping.}
@end float

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to 24AA64T datasheet
@end table

@c ##########################################################################
@node Configuration
@chapter Configuration

The @ref{fig:adc_core_fs_clk} is a block diagram of the ADC core part in the sampling clock domain. It contains a ADC data stream de-serialiser, an offset and gain correction (of ADC data)block, an under-sampling block and a trigger unit.
The four channels data and the trigger signal are synchronised to the system clock domain using a FIFO.
The configuration signals coming from registers in the system clock domain are synchronised to the sampling clock within the Wishbone slave (wbgen2 feature).

@float Figure,fig:adc_core_fs_clk
@center @image{../../figures/adc_core_fs_clk, 15cm,,,pdf}
@caption{ADC core diagram (sampling clock domain).}
@end float


@c --------------------------------------------------------------------------
@section Input ranges

The @ref{fig:analogue_input} shows a simplified schematics of the analogue input used for each channel.
Each input can be independantly configured with one of the three available ranges; 100mV, 1V, 10V.
Each range is defined as the maximum peak-to-peak input voltage.
Independantly to the selected range, a 50ohms termination can be added to each input.

@float Figure,fig:analogue_input
@center @image{../../figures/analogue_input, 15cm,,,pdf}
@caption{Simplified schematics of the analogue input.}
@end float

Only the following input switch configurations are valid.
For all others switch configurations, the behaviour is not defined and therefore shouldn't be used.

@float Table,tab:switch_config
@multitable {SW[7..1]}{SW7}{SW6}{SW5}{SW4}{SW3}{SW2}{SW1}{100mV range offset calibration}
@headitem SW[7..1] @tab SW7 @tab SW6 @tab SW5 @tab SW4 @tab SW3 @tab SW2 @tab SW1 @tab Description
@item @code{0x23} @tab @code{OFF} @tab @code{ON}  @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{ON}  @tab 100mV range
@item @code{0x11} @tab @code{OFF} @tab @code{OFF} @tab @code{ON}  @tab @code{X}   @tab @code{OFF} @tab @code{OFF} @tab @code{ON}  @tab 1V range
@item @code{0x45} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{ON}  @tab @code{OFF} @tab @code{ON}  @tab 10V range
@item @code{0x42} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{OFF} @tab 100mV range offset calibration
@item @code{0x40} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{ON}  @tab 1V range offset calibration
@item @code{0x44} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab 10V range offset calibration
@item @code{0x00} @tab @code{X}   @tab @code{OFF} @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{X}   @tab @code{OFF} @tab Input disconnected
@item @code{0x08} @tab @code{X}   @tab @code{X}   @tab @code{X}   @tab @code{ON}  @tab @code{X}   @tab @code{X}   @tab @code{X}   @tab 50ohm termination
@end multitable
@caption{Analogue input switches configurations.}
@end float

@table @b
@item TODO
      Calibration input configuration.
@end table

@c --------------------------------------------------------------------------
@section Input offset

Each channel has a 16-bit DAC allowing to apply a dc offset to the input signal.
The voltage range of the DAC is 10V (-5V to +5V) and is independent from the selected input range.

The following equation shows how to convert a digital value written to a DAC to an offset voltage.

@example
@group
v_dac = v_ref * d_dac/0x8000
Where:
v_ref = DAC's voltage reference = 5V
d_dac = Digital value written to the DAC
v_dac = DAC voltage
@sp 1
@end group
@end example

The following equation shows the relation between the input voltage and the offset (applied by the DAC).
Note that the offset from the DAC is subtracted from the input voltage.

@example
@group
v_out = v_in - v_dac
Where:
v_in  = Input voltage
v_dac = DAC voltage
v_out = Output voltage (to filter and ADC)
@sp 1
@end group
@end example

@c --------------------------------------------------------------------------
@section Trigger

The trigger unit is made of a hardware and a software source.
Each hardware and software sources can be enabled independantly.
The two sources are then or'ed together to drive a delay generator.
The delay generator allows to insert an defined number of sampling clock period before the trigger goes to the acquisition state machine.
The hardware trigger source can be either internal (based on an adc input channel) or external (dedicated trigger input).
For both internal and external sources, the polarity can be selected between positive and negative slope (resp. rising and falling edge). By default the polatity is set to positive slope.
For the internal trigger source, the adc input channel and the threshold should be configured.
By default, the channel 1 is selected and the threshold is set to 0.
Note that the threshold is 16-bit signed (two's complement).
The @ref{fig:trig_hw_int} sketches the internal hardware trigger threshold behaviour.
The software trigger source concists in a pulse generated when a write cycle is detected on the "Software trigger".
The @ref{fig:trig_unit} shows the different trigger configurations.
For futher information on the trigger configuration registers @pxref{ADC core registers}.

@float Figure,fig:trig_unit
@center @image{../../figures/trigger_unit, 15cm,,,pdf}
@caption{Trigger unit diagram.}
@end float

@float Figure,fig:trig_hw_int
@center @image{../../figures/trig_hw_int, 15cm,,,pdf}
@caption{Internal hardware trigger trheshold.}
@end float

@table @b
@item TODO
External trigger input synch, glitch filter, expected 100MHz fs_clk (-> could be a limitation), input bandwidth (or reflexions killing input signal)...
@end table

@c --------------------------------------------------------------------------
@section Undersampling

The undersampling block is simply validating one in N samples and forwarding it to the acquisition logic.
The number (N) is configured in the "Sample rate" register.
If N > 1, then the trigger pulse is aligned to the next valid sample.
If N = 1 all the samples are valid and therefore the trigger is always aligned.
A value of N = 0 is treated as N = 1 in the firmware.

@b{Note:} Undersampling might be unaccurately called decimation in the documentation or source code.


@c --------------------------------------------------------------------------
@section Time-stamping

@table @b
@item TODO
Setting counters (e.g. with host OS time, ntp)
@item TODO
WR benefits -> improvement section.
@end table



@c ##########################################################################
@node Calibration
@chapter Calibration

The calibration is done once during the prodoction tests.
It can be repeated afterwards with the production test suite (PTS) and the corresponding testbench.
The calibration process gives four values per channel and per input range:
ADC gain correction, ADC offset correction, DAC gain correction and DAC offset correction.
The temperature during the calibration process is also measured.
All the calibration values are stored in the FmcAdc100m14b4cha EEPROM.
The EEPROM holds a sdbfs@footnote{http://www.ohwr.org/attachments/download/1594/sdbfs-2012-09-19.pdf} file system.
In addition to the calibration values, the EEPROM also contains mandatory IPMI@footnote{Platform Management FRU Information Storage Definition v1.0} 
records described in the FMC Standard VITA 57.1 (see table @ref{tab:eeprom_sdbfs} for mapping).

@float Table,tab:eeprom_sdbfs
@multitable @columnfractions .12 .18 .15 .30
@headitem Byte offset @tab File name @tab File Type @tab Description
@item @code{0x0}    @tab ipmi.sdb        @tab binary @tab IPMI records
@item @code{0x100}  @tab calibration.sdb @tab binary @tab Calibration values
@item @code{0x1000} @tab .               @tab binary @tab Directory
@item               @tab                 @tab        @tab vendor = 0xCE42
@item               @tab                 @tab        @tab device = 0xC5BE045E
@end multitable
@caption{EEPROM sdb file system.}
@end float

Note that the vendor value 0xCE42 corresponds to CERN. While the device value 0xC5BE045E corresponds to the first 32-bit of the md5 sum of "fmc-adc-100m14b4cha".

Two registers per channel are implemented in the FPGA for ADC gain and offset correction.
When an input range is selected, the corresponding gain/offset correction values must be loaded from the EEPROM to those registers.

As the DAC value is set once before an acquisition, there is no need to implement the gain and offset correction in the FPGA.
Therefore gain and offset correction must be applied to the DAC value by the software.

Below is the pseudo-code to calculate the DAC corrected value, applying gain and offset correction:

@code{c_val = ((((val-0x8000+offset) << 15) * gain) >> 30)+0x8000}

where:

@code{c_val  = corrected value to write to DAC}

@code{val    = value from user}

@code{offset = DAC offset calibration value from EEPROM}

@code{gain   = DAC gain calibration value from EEPROM}


@c ##########################################################################
@node Acquisition
@chapter Acquisition



@float Figure,fig:acq_fsm
@center @image{../../figures/acq_fsm, 15cm,,,pdf}
@caption{Acquisition state machine.}
@end float

@float Figure,fig:adc_core_sys_clk
@center @image{../../figures/adc_core_sys_clk, 15cm,,,pdf}
@caption{ADC core diagram (system clock domain).}
@end float

@c --------------------------------------------------------------------------
@section Single shot mode

@itemize
@item State machine
@item Memory management (with figure)
@item ...
@end itemize


@c --------------------------------------------------------------------------
@section Multi-shot mode

@itemize
@item State machine
@item Memory management (with figure)
@item ...
@end itemize

@c ##########################################################################
@node Improvements
@chapter Improvements

@table @b
@item TODO
WR -> time-tag, sampling clock control...
@item TODO
...
@end table



@c ##########################################################################
@page
@node Appendix
@appendix

@c --------------------------------------------------------------------------
@section Calibration data storage in EEPROM
Tables @ref{tab:adc_calibr_data_eeprom} and @ref{tab:dac_calibr_data_eeprom} shows the calibration data types and the arrangement in the binary file.
The first column "Byte offset" represents the offset within the binary file.

@float Table,tab:adc_calibr_data_eeprom
@multitable @columnfractions .10 .10 .35 .40
@headitem Byte offset @tab Input range @tab Description @tab Type
@item @code{0x0} @tab 10V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x2} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x4} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x6} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x8} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0xA} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0xC} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0xE} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x10} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x12} @tab 1V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x14} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x16} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x18} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x1A} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x1C} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x1E} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x20} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x22} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x24} @tab 100mV @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x26} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x28} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x2A} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x2C} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x2E} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x30} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x32} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x34} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@end multitable
@caption{ADC calibration data stored in EEPROM (calibration.sdb file).}
@end float

@float Table,tab:dac_calibr_data_eeprom
@multitable @columnfractions .12 .12 .30 .30
@headitem Byte offset @tab Input range @tab Description @tab Type
@item @code{0x36} @tab 10V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x38} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x3A} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x3C} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x3E} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x40} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x42} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x44} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x46} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x48} @tab 1V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x4A} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x4C} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x4E} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x50} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x52} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x54} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x56} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x58} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x5A} @tab 100mV @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x5C} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x5E} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x60} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x62} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x64} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x66} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x68} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x6A} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@end multitable
@caption{DAC calibration data stored in EEPROM (calibration.sdb file).}
@end float

@c --------------------------------------------------------------------------
@c macro to allow includes from wbgen2 generated tex register documentation
@macro regsection{name}
@section \name\
@end macro

@c --------------------------------------------------------------------------
@appendix ADC core registers
@anchor{ADC core registers}
   @include fmc_adc_100Ms_csr.tex

@c --------------------------------------------------------------------------
@appendix Interrupt controller registers
@anchor{Interrupt controller registers}
   @include irq_controller_regs.tex

@c --------------------------------------------------------------------------
@appendix UTC core registers
@anchor{UTC core registers}
   @include utc_core_regs.tex

@c --------------------------------------------------------------------------
@appendix Carrier registers
@anchor{Carrier registers}
   @include carrier_csr.tex

@c --------------------------------------------------------------------------
@appendix Glossary
@section Glossary

@table @b
@item Local bus
      The @b{local bus} is the interface between the GN4124 and the FPGA.
@item Pulse
      In this document, a @b{pulse} refers to a one clock tick wide pulse.
@item Tick
      A clock @b{tick} corresponds to a period of the clock.
@end table



@bye
