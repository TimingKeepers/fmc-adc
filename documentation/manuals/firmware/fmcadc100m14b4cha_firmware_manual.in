\input texinfo    @c -*-texinfo-*-
%
% fmcadc100m14b4cha_firmware_manual.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding UTF-8
@setfilename fmcadc100m14b4cha_firmware_manual.info
@settitle fmcadc100m14b4cha_firmware_manual
@iftex
@afourpaper
@end iftex
@c @paragraphindent 0
@comment %**end of header

@setchapternewpage on

@set update-month April 2013

@finalout

@titlepage
@title FmcAdc100m14b4cha Firmware Guide
@subtitle @value{update-month}
@subtitle For Simple PCIe FMC Carrier (SPEC)
@sp 10
@center @image{../../figures/cern_logo,3cm,,,pdf} @hfill @image{../../figures/ohr_logo,3cm,,,pdf}
@author Matthieu Cattin (CERN)
@end titlepage
@headings single

@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This document describes the hdl (gateware) developed to support the FmcAdc100m14b4cha@footnote{http://www.ohwr.org/projects/fmc-adc-100m14b4cha} (later refered to as fmc-adc) mezzanine card on the SPEC@footnote{http://www.ohwr.org/projects/spec} carrier card.
The gateware architecture is describled in detail.
The configuration and operation of the gateware is also explained.
On the other hand, this manual is not intended to provide information about the software used to control the fmc-adc board.

@table @b
@item TODO
      ADD ref to fmc-adc sw manual...
@end table

@c ##########################################################################
@node Architecture
@chapter Architecture

This chapter describes the internal blocks of the FPGA.
All blocks (except the memory controller) are connected to the PCIe bridge interface using a Wishbone bus. The DDR memory can only be access through DMA.
The @ref{fig:firmware_arch} illustrates the FPGA architecture. The peripherals connected to each block are also shown.
A crossbar from the general-cores@footnote{http://www.ohwr.org/projects/general-cores} library is used to map the Wishbone slaves in the BAR 0 address space.
The @ref{tab:memory_map} shows the memory mapping.

@float Table,tab:memory_map
@multitable {Byte offset}{xwb_onewire_master}{fmc-adc-100m14b4cha}{Mezzanine system @math{I^2C} master}
@headitem Byte offset @tab Core @tab Library @tab Description
@item @code{0x0000} @tab sdb_rom            @tab general-cores       @tab SDB records
@item @code{0x1000} @tab gn4124_core        @tab gn4124-core         @tab DMA controller
@item @code{0x1100} @tab -                  @tab -                   @tab Carrier SPI master@footnote{Not implemented.}
@item @code{0x1200} @tab xwb_onewire_master @tab general-cores       @tab Carrier 1-wire master
@item @code{0x1300} @tab carrier_csr        @tab fmc-adc-100m14b4cha @tab Carrier control and status
@item @code{0x1400} @tab utc_core           @tab fmc-adc-100m14b4cha @tab Time-tagging core
@item @code{0x1500} @tab irq_controller     @tab fmc-adc-100m14b4cha @tab Interrupt controller
@item @code{0x1600} @tab xwb_i2c_master     @tab general-cores       @tab Mezzanine system @math{I^2C} master
@item @code{0x1700} @tab xwb_spi            @tab general-cores       @tab Mezzanine SPI master
@item @code{0x1800} @tab xwb_i2c_master     @tab general-cores       @tab Mezzanine @math{I^2C} master
@item @code{0x1900} @tab fmc_adc_100Ms_core @tab fmc-adc-100m14b4cha @tab ADC core
@item @code{0x1A00} @tab xwb_onewire_master @tab general-cores       @tab Mezzanine 1-wire master
@end multitable
@caption{Wishbone bus memory mapping (BAR 0).}
@end float

The Wishbone crossbar also implements SDB@footnote{http://www.ohwr.org/projects/fpga-config-space} records. Those records describe the Wishbone slaves and their mapping on the bus.
The SDB records ROM must be located at offset @code{0x0}.
In order to identify the gateware, SDB meta-information records are used.
The following three meta-information records are used in the design:
@table @b
@item Integration
      vendor_id = 0x0000CE42 (CERN vendor ID)@*
      device_id = 0x47C786A2 (echo "spec_fmc-adc-100m14b4cha"|md5sum|cut -c1-8) @*
      version   = [31:16]=major, [15:0]=minor, bcd encoded@*
      date      = release date, format yyyymmdd@*
      name      = "spec_fmcadc100m14b"
@item Top module repository url
      repo_url = "git://ohwr.org/fmc-projects/fmc-adc-100m14b4cha.git"
@item Synthesis tool information
      syn_module_name  = "spec_top_fmc_adc"@*
      syn_commit_id    = git log -1 --format="%H" | cut -c1-32 @*
      syn_tool_name    = "ISE"@*
      syn_tool_version = bcd encoded synthesis tool version@*
      syn_date         = synthesis date, format yyyymmdd@*
      syn_username     = "mcattin" (synthesised by)
@end table


Note that some of the cores from the general-cores library are based on cores from OpenCores@footnote{http://opencores.org/}. Therefore, the documentation for those cores is hosted on the OpenCores website.

The register description for the cores for the carrier control and status, the time-tagging core, the interrupt controller and the ADC core can be found in annexe.

@float Figure,fig:firmware_arch
@center @image{../../figures/firmware_arch, 15cm,,,pdf}
@caption{FPGA firmware architecture block diargam.}
@end float

There are three different Wishbone bus in the design.
@table @b
@item Mapped WB bus (blue)
      This bus connects all the peripheral to the GN4142 core.@*
      Data: 32-bit, address: 32-bit (word aligned), clock: system clock (125MHz).
@item ADC core to memory controller (orange)
      This bus is used to write samples from the ADC core to the DDR memory.@*
      Data: 64-bit, address: 32-bit (word aligned), clock: system clock (125MHz).
@item Memory controller to GN4124 core (red)
      This bus is used to read samples from the DDR memory.@*
      Data: 32-bit, address: 32-bit (word aligned), clock: system clock (125MHz).
@end table

@c --------------------------------------------------------------------------
@section Clock domains

The fmc-adc design has four different clock domains. They are listed in the followig table.

@float Table,tab:clocks
@multitable {@code{sys_clk_125}}{DDR interface clock}{125.00 MHz}{Si570 on the fmc-adc mezzanine.}
@headitem Name @tab Description @tab Frequency @tab Source
@item @code{sys_clk_125} @tab Main system clock @tab 125.00 MHz @tab 20MHz TCXO (carrier)
@item @code{ddr_clk} @tab DDR interface clock @tab 333.33 MHz @tab 20MHz TCXO (carrier)
@item @code{fs_clk} @tab Sampling clock @tab 100.00 MHz @tab Si570 (mezzanine)
@item @code{p2l_clk} @tab Local bus clock @tab 200.00 MHz @tab GN4124 (carrier)
@end multitable
@caption{Clock domains.}
@end float

@quotation Note
By default, the sampling clock is 100MHz. But it can be changed to any frequency from 10MHz to 105MHz. The lower bound is defined by the Si570 programmable oscillator. While the upper bound is limited by the LTC2174 ADC.
@end quotation

@c --------------------------------------------------------------------------
@section GN4124 core

This block is the interface between the GN4124@footnote{PCI Express bridge from Semtech (formerly Gennum)} local bus and the other blocks in the FPGA.
The GN4124 is a four lane PCI Express Generation 1.1 bridge. In addition to th PHY, it also contains the data link and transaction layers.
The GN4124 bridge is used to access the FPGA registers, but also to generate MSI interrupts and re-program the FPGA.
The BAR 4 (Base Address Register) allows access to the GN4124 internal registers.
The BAR 0 is connected to the local bus and therefore allows access to the FPGA.

The GN4124 core is made of a local bus interface with the GN4124 chip, a Wishbone bus master mapped to BAR0 and a DMA controller. The DMA controller has two Wishbone ports, a Wishbone slave to configure the DMA controller and a Wishbone master to access the DDR memory.
The GN4124 Wishbone interfaces (masters and slave) are 32-bit data width and 32-bit word aligned addresses.

@quotation Note
It is not possible to insert an address converter (for non-interleaved data read) between the GN4124 core and the memory controller.
Because the DDR memory access is not efficiant when reading non-consecutive addresses.
@end quotation

@c --------------------------------------------------------------------------
@section Carrier control and status

This block contains control and status registers related to the carrier board.
A first register allows to readout the carrier PCB revision and carrier type.
Another register signals the presence of a mezzanine in the FMC slot, gives the status of the local bus and system PLLs and indicates the DDR memory controller calibration state.
The last register of this block allows to control the carrier's LEDs on the front panel. There is on red and one green LED.

@c --------------------------------------------------------------------------
@section Carrier 1-wire master

This 1-wire master controls the DS18B20 thermometer chip located on the carrier board.
This chip also contains a unique 64-bit identifier.
This block is based on an OpenCores design.

http://opencores.org/websvn,filedetails?repname=sockit_owm&path=%2Fsockit_owm%2Ftrunk%2Fdoc%2Fsockit_owr.pdf

@table @b
@item TODO
      add ref to opencores doc
@end table

@c --------------------------------------------------------------------------
@section Carrier SPI master

The carrier SPI master is not implemented. It is meant to control DACs connected to VCXO for White Rabbit@footnote{http://www.ohwr.org/projects/white-rabbit} applications.

@c --------------------------------------------------------------------------
@section Memory controller

The memory controller block is the interface between the 256MB DDR memory located on the SPEC board and the other blocks in the FPGA.
It is basically a MCB core (Memory Controller Block) generated with Xilinx CoreGen and an additional wrapper implementing two Wishbone slave interfaces.
One of the Wishbone slave interface is connected to the ADC core.
The other Wishbone slave interface is connected to the DMA Wishbone master of the GN4124 core.

@float Table,tab:mem_ctrl_ports
@multitable {WB Slave}{GN4124 core}{Data width}{Access type}
@headitem WB Slave @tab WB Master @tab Data width @tab Access type
@item @code{0} @tab ADC core @tab 64-bit @tab Write only
@item @code{1} @tab GN4124 core @tab 32-bit @tab Read/write
@end multitable
@caption{Memory controller Wishbone interfaces.}
@end float

@table @b
@item TODO
      max bandwidth, concurent access, ...
@item TODO
      add ref to ddr core, xilinx doc
@end table

@c --------------------------------------------------------------------------
@section Interrupt controller

The interrupt controller purpose is to concentrate several interrupt source into one interrupt request line. It has four interrupt inputs and one interrupt request output.
It also have one interrupt enable mask register and one interrupt source register.
Each time a valid rising edge is detected on one of the inputs, a pulse is generated on the interrupt request output.
The interrupt request output is connected to the GPIO 8 of the GN4124 chip.
Note that the GN4124 must be configured to generate a MSI when a rising edge is detected on GPIO 8.
A rising edge is valid if the corresponding bit in the interrupt enable mask register is set.
When a valid rising edge is detected, the corresponding bit in the interrupt source register is set as well. This indicates to the host which source caused the interrput.
To clear a bit in the interrupt source register, a '1' must be written to it.

@noindent There are four interrupt sources in the design. They are listed below.

@table @b
@item DMA done
      This interrupt signals the end of a DMA transfer.
@item DMA error
      This interrupt signals an error in a DMA transfer.
@item Trigger
      This interrupt signals that a valid trigger arrived while the acquisition state machine was in the @code{WAIT_TRIG} state.
@item Acquisition end
      This interrupt signals the end of an acquisition. In case of multi-shot acquisition, it occurs at the end of the last shot.
@end table

@table @b
@item TODO
      explain the multi-irq register (or remove it!)
@end table

@c --------------------------------------------------------------------------
@section Time-tagging core

This block allows time-tagging of important events in the ADC core.
It is based on a seconds counter and a 125MHz system clock ticks counter.
Those two counters are accessible in read/write mode via registers.
To time-tag the events, the ADC core sends pulses to the time-tagging core.
The following events are time-tagged; trigger, acquisition start, acquisition stop and acquisition end.

@c --------------------------------------------------------------------------
@section ADC core

The ADC core is the main block of the design.
On the mezzanine interface side, it takes a data flow from the LTC2174 ADC chip, an external trigger and controls the analogue switches to select the input range or calibration mode.
On the internal interface side, it has a Wishbone master to write data to the DDR memory controller.
It also has a Wishbone slave to access the core's control and status regiters.
In addition, it outputs the following event as pulses:
@itemize @textdegree
@item Trigger
@item Acquisition start
@item Acquisition stop
@item Acquisition end
@end itemize
The internal detailed functionning of this block is described further in the document(@xref{Configuration}, @ref{Acquisition} and @ref{Calibration}).

@c --------------------------------------------------------------------------
@section Mezzanine SPI master

This SPI master controls the LTC2174 ADC and the four MAX5442 offset DACs.
The following table shows how the peripherals are wired to the core.
This block is based on an OpenCores design.

@float Table,tab:spi_ss
@multitable @columnfractions .12 .35
@headitem Slave select @tab Peripheral
@item @code{0} @tab LTC2174 ADC
@item @code{1} @tab MAX5442 DAC for channel 1
@item @code{2} @tab MAX5442 DAC for channel 2
@item @code{3} @tab MAX5442 DAC for channel 3
@item @code{4} @tab MAX5442 DAC for channel 4
@end multitable
@caption{Mezzanine SPI slave select lines mapping.}
@end float

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to LTC2174, MAX5442 datasheet
@end table

@c --------------------------------------------------------------------------
@section Mezzanine 1-wire master

This 1-wire master controls the DS18B20 thermometer chip located on the mezzanine board.
This chip also contains a unique 64-bit identifier.
This block is based on an OpenCores design.

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to DS18B20 datasheet
@end table

@c --------------------------------------------------------------------------
@section Mezzanine @math{I^2C} master

This @math{I^2C} master controls the Si570 programmable oscillator chip located on the mezzanine board.
This chip is used to produce the ADC sampling clock.
This block is based on an OpenCores design.

@float Table,tab:i2c_slave
@multitable @columnfractions .15 .50
@headitem Slave address @tab Peripheral
@item @code{0x55} @tab Si570 programmable oscillator
@end multitable
@caption{Mezzanine @math{I^2C} slaves mapping.}
@end float

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to Si570 datasheet
@end table

@c --------------------------------------------------------------------------
@section Mezzanine system management @math{I^2C} master

This @math{I^2C} master access the 24AA64T 64Kb EEPROM memory chip located on the mezzanine board.
This memory is mandatory as specified in the FMC standard (VITA 57.1). It is connected to the system management @math{I^2C} bus, also specified in the FMC standard.
This block is based on an OpenCores design.

@float Table,tab:sys_i2c_slave
@multitable @columnfractions .15 .50
@headitem Slave address @tab Peripheral
@item @code{0x50} @tab 24AA64T 64Kb EEPROM memory
@end multitable
@caption{Mezzanine system management @math{I^2C} slaves mapping.}
@end float

@table @b
@item TODO
      add ref to opencores doc
@item TODO
      add ref to 24AA64T datasheet
@end table

@c ##########################################################################
@node Configuration
@chapter Configuration

The @ref{fig:adc_core_fs_clk} is a block diagram of the ADC core part in the sampling clock domain. It contains a ADC data stream de-serialiser, an offset and gain correction block (for ADC data), an under-sampling block and a trigger unit.
The four channels data and the trigger signal are synchronised to the system clock domain using a FIFO.
The configuration signals coming from registers in the system clock domain are synchronised to the sampling clock within the Wishbone slave (wbgen2@footnote{http://www.ohwr.org/projects/wishbone-gen} feature).

@float Figure,fig:adc_core_fs_clk
@center @image{../../figures/adc_core_fs_clk, 15cm,,,pdf}
@caption{ADC core diagram (sampling clock domain).}
@end float

@table @b
@item TODO
      Data bus format (4ch x (14-bit << 2))...
@end table

@c --------------------------------------------------------------------------
@section Input ranges

The @ref{fig:analogue_input} shows a simplified schematics of the analogue input used for each channel.
Each input can be independantly configured with one of the three available ranges; 100mV, 1V, 10V.
Each range is defined as the maximum peak-to-peak input voltage.
Independantly to the selected range, a 50ohms termination can be added to each input.

In addition to the three ranges for normal operation, there are three more configurations used for offset calibration of each range.

Opto-isolated analogue switches allow the different configurations. They are represented by normal switched in the simplified schematics.

@float Figure,fig:analogue_input
@center @image{../../figures/analogue_input, 15cm,,,pdf}
@caption{Simplified schematics of the analogue input.}
@end float

Only the following input switch configurations are valid.
For all others switch configurations, the behaviour is not defined and therefore shouldn't be used.

@float Table,tab:switch_config
@multitable {SW[7..1]}{SW7}{SW6}{SW5}{SW4}{SW3}{SW2}{SW1}{100mV range offset calibration}
@headitem SW[7..1] @tab SW7 @tab SW6 @tab SW5 @tab SW4 @tab SW3 @tab SW2 @tab SW1 @tab Description
@item @code{0x23} @tab @code{OFF} @tab @code{ON}  @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{ON}  @tab 100mV range
@item @code{0x11} @tab @code{OFF} @tab @code{OFF} @tab @code{ON}  @tab @code{X}   @tab @code{OFF} @tab @code{OFF} @tab @code{ON}  @tab 1V range
@item @code{0x45} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{ON}  @tab @code{OFF} @tab @code{ON}  @tab 10V range
@item @code{0x42} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{OFF} @tab 100mV range offset calibration
@item @code{0x40} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{OFF}  @tab @code{OFF}  @tab 1V range offset calibration
@item @code{0x44} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab 10V range offset calibration
@item @code{0x00} @tab @code{X}   @tab @code{OFF} @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{X}   @tab @code{OFF} @tab Input disconnected
@item @code{0x08} @tab @code{X}   @tab @code{X}   @tab @code{X}   @tab @code{ON}  @tab @code{X}   @tab @code{X}   @tab @code{X}   @tab 50ohm termination
@end multitable
@caption{Analogue input switches configurations.}
@end float

@c --------------------------------------------------------------------------
@section Input offset

Each channel has a 16-bit DAC allowing to apply a dc offset to the input signal.
The voltage range of the DAC is 10V (-5V to +5V) and is independent from the selected input range.
The following equation shows how to convert a digital value written to a DAC to an offset voltage.

@example
@group
v_dac = v_ref * d_dac/0x8000
Where:
v_ref = DAC's voltage reference = 5V
d_dac = Digital value written to the DAC
v_dac = DAC voltage
@end group
@end example

The following equation shows the relation between the input voltage and the offset (applied by the DAC).
Note that the offset from the DAC is subtracted from the input voltage.

@example
@group
v_out = v_in - v_dac
Where:
v_in  = Input voltage
v_dac = DAC voltage
v_out = Output voltage (to filter and ADC)
@end group
@end example

@c --------------------------------------------------------------------------
@section Trigger

The trigger unit is made of a hardware and a software source.
Each hardware and software sources can be enabled independantly.
The two sources are then or'ed together to drive a delay generator.
The delay generator allows to insert an defined number of sampling clock period before the trigger goes to the acquisition state machine.
The hardware trigger source can be either internal (based on an adc input channel) or external (dedicated trigger input).
For both internal and external hardware triggers, the polarity can be selected between positive and negative slope (resp. rising and falling edge). By default the polatity is set to positive slope.
The external trigger input is synchronised to the sampling clock. The external trigger pulse must be at least one sampling clock cycle wide.
For the internal trigger source, the adc input channel and the threshold should be configured.
By default, the channel 1 is selected and the threshold is set to 0.
Note that the threshold is 16-bit signed (two's complement).
The @ref{fig:trig_hw_int} sketches the internal hardware trigger threshold behaviour.
The software trigger source concists in a pulse generated when a write cycle is detected on the @i{Software trigger} register.
The @ref{fig:trig_unit} shows the different trigger configurations.
For futher information on the trigger configuration registers @pxref{ADC core registers}.

@float Figure,fig:trig_unit
@center @image{../../figures/trigger_unit, 15cm,,,pdf}
@caption{Trigger unit diagram.}
@end float

@float Figure,fig:trig_hw_int
@center @image{../../figures/trig_hw_int, 12cm,,,pdf}
@caption{Internal hardware trigger trheshold.}
@end float

@table @b
@item TODO
Ext trigger input bandwidth (or reflexions killing input signal)...
@end table

@c --------------------------------------------------------------------------
@section Undersampling

The undersampling block is simply validating one in N samples and forwarding it to the acquisition logic.
The number (N) is configured in the @i{Sample rate} register.
If N > 1, then the trigger pulse is aligned to the next valid sample.
If N = 1 all the samples are valid and therefore the trigger is always aligned.
A value of N = 0 is treated as N = 1 in the firmware.

@quotation Note
Undersampling might be unaccurately called decimation in the documentation or source code.
@end quotation

@c --------------------------------------------------------------------------
@section Time-taging

The time-tagging core contains two free running counters.
The first one counts seconds and the second one counts system clock ticks (8ns resolution).
The system clock ticks counter is alos called coarse counter.
Those two counters can be set via the cores's Wishbone interface.

For example, the host computer can use the OS time to set the seconds counter and simply reset the coarse counter.

It is planned, in a later release, to set the time-tagging core counters using the White Rabbit core, for more details @pxref{Improvements}.

@c ##########################################################################
@node Calibration
@chapter Calibration

The calibration is done once during the production tests.
It can be repeated afterwards with the production test suite (PTS) and the corresponding testbench.
The calibration process gives the following four values per channel and per input range:
@itemize @textdegree
@item ADC gain correction
@item ADC offset correction
@item DAC gain correction
@item DAC offset correction
@end itemize

Note that the temperature during the calibration process is also measured.
This could be used for later temperature compensated calibration value computing.

@c --------------------------------------------------------------------------
@section Calibration data storage
All the calibration values are stored in the FmcAdc100m14b4cha EEPROM.
The EEPROM holds a sdbfs@footnote{http://www.ohwr.org/attachments/download/1594/sdbfs-2012-09-19.pdf} file system.
In addition to the calibration values, the EEPROM also contains mandatory IPMI@footnote{Platform Management FRU Information Storage Definition v1.0} records specified in the FMC Standard VITA 57.1 (see table @ref{tab:eeprom_sdbfs} for mapping).

@float Table,tab:eeprom_sdbfs
@multitable @columnfractions .12 .18 .15 .30
@headitem Byte offset @tab File name @tab File Type @tab Description
@item @code{0x0}    @tab ipmi.sdb        @tab binary @tab IPMI records
@item @code{0x100}  @tab calibration.sdb @tab binary @tab Calibration values
@item @code{0x1000} @tab .               @tab binary @tab Directory
@item               @tab                 @tab        @tab vendor = 0xCE42
@item               @tab                 @tab        @tab device = 0xC5BE045E
@end multitable
@caption{EEPROM sdb file system.}
@end float

Note that the vendor value 0xCE42 corresponds to CERN. While the device value 0xC5BE045E corresponds to the first 32-bit of the md5 sum of "fmc-adc-100m14b4cha".

@c --------------------------------------------------------------------------
@section Calibration data usage

@subsection ADC calibration
Two registers per channel are implemented in the FPGA for ADC gain and offset correction.
When an input range is selected, the corresponding gain/offset correction values must be loaded from the EEPROM to those registers.

@float Figure,fig:off_gain_corr
@center @image{../../figures/offset_gain_corr, 10cm,,,pdf}
@caption{ADC offset and gain correction block.}
@end float

@quotation Note
On FPGA start-up, the gain registers are set to 0x8000 (1.000) and the offset registers to 0x0000.
This means a unit gain and no offset.
@end quotation


@subsection DAC calibration
The DAC value is only set once before an acquisition.
Therefore, there is no need to implement the gain and offset correction in the FPGA.
The software controlling the fmc-adc must apply the DAC gain and offset correction prior to write a value to the DAC.
As for the ADC correction values, there is one pair (offset, gain) of DAC correction values per input range.

Below is the pseudo-code to calculate the corrected DAC value (applying gain and offset correction):
@example
@group
c_val = ((((val-0x8000+offset) << 15) * gain) >> 30)+0x8000
where:
c_val  = corrected value to write to DAC
val    = value from user
offset = DAC offset calibration value from EEPROM
gain   = DAC gain calibration value from EEPROM
@end group
@end example


@c ##########################################################################
@node Acquisition
@chapter Acquisition

This chapter describes the two modes of acquisition, single-shot and multi-shot.
It also explains how the software is expected to control the fmc-adc acquisitions.

The @ref{fig:adc_core_sys_clk} shows the ADC core acquisition logic.
The heart of the acquisition logic is a state machine driven by user commands (start, stop), the trigger signal and counters events (e.g. pre-trig done, etc...).
The ADC samples are routed along a datapath (bold arrows), which depends on the acquisition mode.
It is explained in detail in the @ref{Single-shot mode} and @ref{Multi-shot mode}.
The four channels data and the trigger are concatenated together and fed to a FIFO to be synchronised between the sampling clock domain and the system clock domain.
Even if the LTC2174 ADC is 14-bit, the data of each channel is stored in a 16-bit word.
The 14 bits of ADC data takes the MSB part of the 16-bit word and the two LSBs are set to 0.
Along the datapath, we call @i{sample} a 64-bit vector containing a sample for each channel.
At the output of the ADC core, a flow control FIFO allows to cope with the memory controller temporary unavailabilities (due to DDR refresh cycles).

@float Figure,fig:adc_core_sys_clk
@center @image{../../figures/adc_core_sys_clk, 15cm,,,pdf}
@caption{Acquisition logic diagram (system clock domain).}
@end float

Samples are stored interleaved in the DDR memory.
The @ref{fig:mem_samples} illustrates the way samples are written, stored and read in the DDR memory.
The DDR memory size is 2Gb or 256MB.
@w{It means that the maximum number of samples that can be stored is 128M samples (@math{2^{27}*16}).}

@float Figure,fig:mem_samples
@center @image{../../figures/memory_samples, 15cm,,,pdf}
@caption{Illustation of samples storage in DDR memory.}
@end float

The acquisition process is driven by a state machine.
The @ref{fig:acq_fsm} represents its states and transitions.
At start-up, the state machine is @code{IDLE}, waiting for an acquisistion start command (@code{ACQ_START}).
Commands are sent to the state machine by writing in the @code{FSM_CMD} field of the control register (@pxref{ADC core registers}).
When a start command is received, the state machine goes to @code{PRE_TRIG} and stays in this state until the programmed number of pre-trigger samples are recorded.
After that, it goes in @code{WAIT_TRIG} state and continue recording sample to memory.
When a valid trigger is detected, the state machine moves to @code{POST_TRIG}.
It will stays in this state until the programmed number of post-trigger samples is reached.
Then, depending on the mode, the state machine either goes back to @code{IDLE} (single-shot mode) or to @code{PRE_TRIG} (multi-shot mode).
When the acquisition is terminated (state machine back to @code{IDLE}) and all samples have been written to the DDR memory, only then the software can retrieve the samples using DMA transfer.
An interrupt is generated when the acquisition ends.

@quotation Note
Start commands are taken into account only in @code{IDLE} state.
@end quotation

@quotation Note
Trigger are taken into account only in @code{WAIT_TRIG} state.
@end quotation

@quotation Note
A stop command will bring the state machine back to @code{IDLE} from any state.
@end quotation

@float Figure,fig:acq_fsm
@center @image{../../figures/acq_fsm, 10cm,,,pdf}
@caption{Acquisition state machine.}
@end float

There are two LED on the fmc-adc front panel.
The LED labeled @code{ACQ} is turned ON when the acquisition state machine is @b{not} in the @code{IDLE} state.
The LED labeled @code{TRIG} flashes when a valid trigger is detected @b{and} the acquisition state machine is in the @code{WAIT_TRIG} state.

@table @b
@item TODO
      end_acq interrupt after acq_stop command ??
@item TODO
      corner cases: pre/post trig = 0, 1
@end table

@c --------------------------------------------------------------------------
@node Single-shot mode
@section Single-shot mode

The procedure below lists the different step of a single-shot acquisition process.

@enumerate
@item Configure acquisition (trigger, number of samples, interrupts, etc...).
@item Issue a start acquisition command (the acquisition state machine must be IDLE).
@item When a valid trigger is detected, an interrupt is generated.
@item At the end of the acquisition, another interrupt is generated.
@item Read trigger position register.
@item Configure the DMA to retreive data.
@item Start the DMA transfer (the acquisition state machine must be IDLE).
@item When the DMA transfer is done, an interrupt is generated.
@item The board is ready for a new acquisition start command.
@end enumerate

In single-shot mode, the DDR memory is used as a circular buffer.
When the acquisition starts, samples are direcly written to the DDR memory (via FIFOs).
The acquisition logic stops writing to the memory when the configured number of pre/post-trigger samples is reached.
It could happen that the write pointer reaches the top of the memory before the end of the acquisition.
In this case, the write pointer is reset to address zero and overwrite previous samples.
In order to allow the software to retreive the requested samples (around the trigger), the @i{Trigger address} register s
tores the write pointer address at the trigger moment.

@quotation Note
The value stored in the @i{Trigger address} register is a sample address (64-bit word address).
@end quotation

@quotation Note
Every new acquisition starts writing at address @code{0x0}.
@end quotation

The @ref{fig:mem_single_shot} and @ref{fig:mem_single_shot_overlap} illustrate the use of the DDR memory as a cicular buffer.
The acquisition state machine is also represented.

@float Figure,fig:mem_single_shot
@center @image{../../figures/memory_single-shot, 15cm,,,pdf}
@caption{Single-shot mode acquisition example.}
@end float

@float Figure,fig:mem_single_shot_overlap
@center @image{../../figures/memory_single-shot_overlap, 15cm,,,pdf}
@caption{Single-shot mode acquisition example (overlapping DDR memory).}
@end float

@quotation Note
@i{Orange}: Samples written to memory and read back via DMA.
@i{Grey}: Samples written to memory, but not read.
@i{White}: Empty memory (or previous acquisition samples).
@end quotation


@c --------------------------------------------------------------------------
@node Multi-shot mode
@section Multi-shot mode

The multi-shot acquisition process is almost identical to the single-shot one, except that once the acquisition is started it will go around the state machine as many time as the number of configured shots.
It means that if the board is configured for N shots, it will generate N trigger interrupts and then another interrupt at the end of the acquisition.

Unlike the single-mode acquisition, in multi-shot, the DDR memory is not used as a circular buffer.
Instead, two dual port RAM (dpram) are implemented inside the FPGA.
Those dprams are alternatively used as circular buffer for each shot.
Even shots uses dpram0 and odd shots dpram1.
@quotation Note
The dprams are 2048 samples deep. It means that the total number of samples (pre-trigger + post-trigger) for a shot cannot exceed 2048.
@end quotation

When a shot is finished, the correcponding dpram samples are written to the DDR memory.
Only the pre-trigger and post-trigger samples are written.
The first shot is written starting at address @code{0x0}.
Then the second shot is written right after the last post-trigger sample of the first shot.
The @ref{fig:mem_multi_shot} shows the shots organisation in the DDR memory.

@float Figure,fig:mem_multi_shot
@center @image{../../figures/memory_multi-shot, 15cm,,,pdf}
@caption{DDR memory usage in multi-shot mode acquisition.}
@end float

@c ##########################################################################
@node Improvements
@chapter Improvements

@table @b
@item TODO
WR -> time-tag, sampling clock control...
@item TODO
...
@end table



@c ##########################################################################
@page
@node Appendix
@appendix

@c --------------------------------------------------------------------------
@section Calibration data storage in EEPROM
Tables @ref{tab:adc_calibr_data_eeprom} and @ref{tab:dac_calibr_data_eeprom} shows the calibration data types and the arrangement in the binary file.
The first column "Byte offset" represents the offset within the binary file.

@float Table,tab:adc_calibr_data_eeprom
@multitable @columnfractions .10 .10 .35 .40
@headitem Byte offset @tab Input range @tab Description @tab Type
@item @code{0x0} @tab 10V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x2} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x4} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x6} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x8} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0xA} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0xC} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0xE} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x10} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x12} @tab 1V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x14} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x16} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x18} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x1A} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x1C} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x1E} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x20} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x22} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x24} @tab 100mV @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x26} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x28} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x2A} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x2C} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x2E} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x30} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x32} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x34} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@end multitable
@caption{ADC calibration data stored in EEPROM (calibration.sdb file).}
@end float

@float Table,tab:dac_calibr_data_eeprom
@multitable @columnfractions .12 .12 .30 .30
@headitem Byte offset @tab Input range @tab Description @tab Type
@item @code{0x36} @tab 10V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x38} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x3A} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x3C} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x3E} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x40} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x42} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x44} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x46} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x48} @tab 1V @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x4A} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x4C} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x4E} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x50} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x52} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x54} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x56} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x58} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@item @code{0x5A} @tab 100mV @tab Offset correction channel 1 @tab 16-bit signed
@item @code{0x5C} @tab @tab Offset correction channel 2 @tab 16-bit signed
@item @code{0x5E} @tab @tab Offset correction channel 3 @tab 16-bit signed
@item @code{0x60} @tab @tab Offset correction channel 4 @tab 16-bit signed
@item @code{0x62} @tab @tab Gain correction channel 1 @tab 16-bit unsigned
@item @code{0x64} @tab @tab Gain correction channel 2 @tab 16-bit unsigned
@item @code{0x66} @tab @tab Gain correction channel 3 @tab 16-bit unsigned
@item @code{0x68} @tab @tab Gain correction channel 4 @tab 16-bit unsigned
@item @code{0x6A} @tab @tab Temperature @tab 16-bit unsigned * 0.01@textdegree{}
@end multitable
@caption{DAC calibration data stored in EEPROM (calibration.sdb file).}
@end float

@c --------------------------------------------------------------------------
@c macro to allow includes from wbgen2 generated tex register documentation
@macro regsection{name}
@section \name\
@end macro

@c --------------------------------------------------------------------------
@appendix ADC core registers
@anchor{ADC core registers}
   @include fmc_adc_100Ms_csr.tex

@c --------------------------------------------------------------------------
@appendix Interrupt controller registers
@anchor{Interrupt controller registers}
   @include irq_controller_regs.tex

@c --------------------------------------------------------------------------
@appendix UTC core registers
@anchor{UTC core registers}
   @include utc_core_regs.tex

@c --------------------------------------------------------------------------
@appendix Carrier registers
@anchor{Carrier registers}
   @include carrier_csr.tex

@c --------------------------------------------------------------------------
@appendix Glossary
@section Glossary

@table @b
@item Local bus
      The @b{local bus} is the interface between the GN4124 and the FPGA.
@item Pulse
      In this document, a @b{pulse} refers to a one clock tick wide pulse.
@item Tick
      A clock @b{tick} corresponds to a period of the clock.
@end table



@bye
